\chapter{Background}

In this chapter we present the existing Cowbird framework described within the SWAN project \cite{swanonline}. Cowbird is a flexible and energy efficient framework for building Android applications that use both smartphone sensors and IoT sensors\cite{cowbirdarticle}. Cowbird extends the SWAN framework \cite{swanphd} and it supports context-based expressions (queries) that can run both on a smartphone and in the cloud; with the Cowbird framework, developers can easily decide where to perform the computation according to the source of the data and the frequency of the updates.

\section{The SWAN Framework}
SWAN (Sensing With Android Nodes) is a framework for easily building context-aware applications for Android smartphones \cite{swanphd}. The framework provides application developers a high-level abstraction for accessing smartphone's sensors. In particular, the SWAN framework is designed to be executed as an Android background service and it acts as a middleware between applications and sensors: running applications can access it through a well-defined API. The SWAN framework reduces storage redundancy and code duplication caused by multiple sensor-based applications running simultaneously. In fact, it provides a centralized solution for collecting and storing data from sensors. 

\subsection{SWAN Sensors}
One of the most important characteristic of SWAN is its \emph{multi sensor support}; at the moment, SWAN supports more than 20 different types of sensors. Below, we describe two categories of sensors:
\begin{itemize}
\item	 \emph{Hardware sensors}. The physical sensors installed on the devices (e.g. accelerometer, GPS).
\item \emph{Software sensors}. Software \emph{data sources} (e.g., calendar, rain prediction, Twitter) that can be installed on the devices or that can run somewhere else. 
\end{itemize}

SWAN sensors are implemented as background services that are responsible for gathering the sensor's data. In case of external software sensors such as the rain prediction or Twitter, the SWAN sensor continuously polls from the web endpoint to get live data. The data accuracy can be improved by increasing the polling frequency. 

From an architectural point of view all the SWAN sensors run in separate processes in order to remain unaffected if the application built on top of SWAN crashes: this design approach prevents data losses. The communication between SWAN sensors and the other components is performed through inter-process communication (IPC).

\subsection{SWAN-Song}
SWAN-Song \cite{swansong} is a domain specific language
for context expressions. SWAN-Song is used by applications to register expressions into SWAN. After registering an expression, SWAN evaluates it and sends back the result to the application. 

The SWAN-Song language is a form of zeroth-order logic, which allows the description of a particular combination of contextual information using sensor based expression predicates. The predicates can be combined using math, comparison, and logic operators, and a specification of a \emph{history window} and \emph{history reduction} operator.  

\subsubsection{SWAN-Song Expressions \& Predicates}
A SWAN-Song expression is composed of two required components and three optional components. The required components are a sensor entity and a value path. The optional components are a list of one or more configuration parameters, a history window and a history reduction mode.

There are two types of SWAN expressions:
\begin{itemize}
\item \emph{Value expressions}. Such expressions return a sensor value or a list of sensor
values. For example, the following expression gets the current light intensity:
\begin{equation} \label{eq:luxexpression}
self@light:lux\big\{MEAN, 2000ms\big\}
\end{equation}
In expression (\ref{eq:luxexpression}) \emph{self} is the location identifier of the device, light
is the sensor name, \emph{lux} is the value path, \emph{MEAN} represents the history reduction mode and \emph{2000ms} indicates the history window. The expression computes the average value generated by the light sensor in the last 2000 milliseconds.

\item \emph{Tristate expressions} Such expressions are useful for defining complex context conditions and they can take one of the following values: TRUE, FALSE or UNDEFINED. An expression is evaluated to UNDEFINED if the sensor queried in the expression is turned off or not available. As an example, the following expression(s) can be used to notify the user that he/she should exercise:
\begin{equation} \label{eq:morningexpression}
Morning = self@time:hour < 12 
\end{equation}
\begin{equation} \label{eq:dryexpression}
Dry = self@rain:expected == 0 
\end{equation}
\begin{equation} \label{eq:mobilityexpression}
Mobility = self@movement:total \big\{MAX,3600000\big\} > 15.0
\end{equation}
\begin{equation} \label{eq:exerciseexpression}
Exercise = Morning \text{ \&\& } Dry \text{ \&\& }  \text{!} (Mobility)
\end{equation}
\end{itemize}
The \emph{Morning} expression (\ref{eq:morningexpression}) uses the time sensor to
check if it is earlier than 12:00 pm; the \emph{Dry} expression (\ref{eq:dryexpression}), instead, checks the live rain prediction using the rain sensor and \emph{Mobility} (\ref{eq:mobilityexpression}) uses the accelerometer sensor to check if the user has been moving in the past hour. The \emph{Exercise} expression (\ref{eq:exerciseexpression}) combines the other TriState expressions to determine whether or not the context of the user is suitable for a workout.

Sensor predicates represent an array of \emph{time-stamped values} because of the time windowing of sensor values. History operators are then applied on these values collected within the time specified time frame. SWAN-Song expressions support different history reduction modes, such as:
\begin{itemize}
\item ALL. This operator checks if \emph{all} the time-stamped values, sensed within the time window, match the condition defined in the SWAN-Song expression.
\item ANY. Selects any value that makes the comparison \emph{true} as the value of the sensor. The ANY operator is also the default history reduction mode.
\item MIN, MAX, MEAN, and MEDIAN, which will select or calculate the appropriate value.
\end{itemize}

\subsection{Architecture}
Android applications can register SWAN-Song expressions using the SWAN API. On registering a new expression, the Expression Evaluation Engine (see Figure \ref{fig:cowbird_architecture}) is invoked. The Expression Evaluation Engine is responsible for evaluating SWAN-Song expressions: it interacts with the sensors in order to fetch the sensed data and computes the result of the expressions. Whenever new sensed data is available, it is sent to the Expression Evaluation Engine, which processes it and sends the result back to the application.

 \begin{figure}[ht!]
\includegraphics[width=1\textwidth]{images/cowbird_architecture.png}
 \caption{SWAN and Cowbird architecture. Cowbirds components are marked with $\otimes$. Source: \cite{cowbirdarticle}}
\label{fig:cowbird_architecture}
\end{figure}

\section{The Cowbird Framework}
The Cowbird framework has been designed as a cloud extension of the SWAN framework. In particular, it enables the combination of smartphone sensors and real-time web data: these data can be originally generated by IoT sensors or any data which can be retrieved by polling a web resource (e.g. Twitter feeds) \cite{cowbirdarticle}. Furthermore, the Cowbird framework reduces the overall communication between the smartphone and the cloud in order to save energy. In fact, the evaluation of phone sensors is performed locally while the evaluation of IoT sensors is computed in the cloud.


The description below has been adapted from \cite{cowbirdarticle} and contains textual overlap with the paper. Some of the core features and characteristics of Cowbird are \cite{cowbirdarticle}:
\begin{itemize}
\item \emph{Flexibility}. The developers using the Cowbird framework
can easily connect to any cloud to offload the evaluation of the IoT sensors.
\item \emph{Usability}. Cowbird uses the SWAN-Song domain specific language to access both sensors in the phone and real-time data.
\item \emph{Portability}. The cloud part of Cowbird is programmed in
Java. Hence, it can be easily ported to any device running a JVM.
\item \emph{Privacy}. Cowbird performs the evaluation of local sensors
on the phone and evaluation of remote IoT sensors remotely. Thus, the sensitive data can be kept and processed locally on the phone.
\item \emph{Energy Efficiency}. Cowbird is designed to minimize the energy consumption of smartphones. Offloading the computation and the communication required to fetch the IoT real-time data (continuous polling from the web) to the cloud will preserve the smartphones battery life.
\item \emph{Mobile Data Cost}. Sending much data through cellular
networks is costly, so Cowbird tries to optimize the communication between the phone and the cloud. The result of the evaluation in the cloud is only sent to the phone if there is a change from the previous result. 
\end{itemize}
\subsection{Cowbird Architecture Details}
Cowbird enriches the SWAN framework designed to be executed on Android smartphones. In particular, Cowbird integrates novel capabilities to the existing SWAN services and it introduces new sensing services to be executed on the cloud. 

The existing SWAN framework has been extended by modifying the SWAN-Song language in order to support \emph{cloud-based expressions}. Furthermore, a new module named \emph{Cloud Manager} has been introduced: it runs on the smartphone and it is responsible for managing the communication with one or more clouds \cite{cowbirdarticle}. 

At the cloud side, the original SWAN evaluation engine has been redesigned to be executed on the cloud. The cloud side of the framework has support for various IoT sensors (implemented as virtual sensors and executed by a different thread) and a mechanism to push data to the phone.

\paragraph{}
We discuss now the typical interaction flow between Cowbird and  third-party app built on top of it. A third-party app uses the SWAN API to register a remote expression to the cloud. The expression is then sent to the evaluation engine service which will forward it to the cloud manager in the phone. The cloud manager checks the location identifier of the expression and sends it to the specified URL. The cloud acknowledges the expression and starts the evaluation by activating the relevant sensor thread. The result of the evaluation from the cloud is received by the cloud manager and is further sent to the evaluation engine in the phone for local processing. The final result is then sent back to the app.

\subsubsection{Remote Expressions in Cowbird}
%	configuration app of the framework
In Cowbird, the location identifier of SWAN-Song has been extended in order to support remote expressions. The developer can add the URL of its cloud in the configuration of the SWAN framework. The developer can then refer to that cloud using \emph{cloud} as location identifier in its SWAN-Song expression. For example, in case of a sound sensor feed available in a certain channel of the ThingSpeak platform \cite{thingspeakonline} we can write a SWAN expression such as:
\begin{equation} \label{eq:cloudthingspeakexpression}
cloud@thingspeak:field?channelid='1'\#field='1'\big\{MEAN,20s\big\} > 50.0
\end{equation}
The expression \ref{eq:cloudthingspeakexpression} checks if the mean value over a period of 20 seconds is greater than 50.0 decibel (dB). 

The developer can also refers to the cloud indicating the endpoint directly in the SWAN-Song expression. For example, the following SWAN-Song expression perform the same evaluation of expression \ref{eq:cloudthingspeakexpression}:
\begin{equation} \label{eq:herokuthingspeakexpressionurl}
url=http://cowbird.herokuapp.com
\end{equation}
\begin{equation} \label{eq:herokuthingspeakexpression}
url@thingspeak: field?channelid='1'\#field='1'\big\{MEAN,20s\big\} > 50.0
\end{equation}
The SWAN-Song expression \ref{eq:herokuthingspeakexpression} assumes to have a Cowbird cloud instance running on Heroku at the URL provided as location identifier of the expression.

A combination of expressions that use smartphone local sensors (accelerometer) and IoT sensors (live data coming from ThingSpeak) can be written as:
\begin{equation}
E1 = self@movement:total\big\{ANY,1000\big\} > 15 
\end{equation}
\begin{equation}
E2 = cloud@thingspeak:field?channelid='1'\#field='1'\big\{MEAN,20s\big\} > 50.0
\end{equation}
\begin{equation} \label{eq:localcombinedexpression}
CombinedExpression = E1 \text{ \&\& } E2
\end{equation}
The evaluation of the local expression (E1) occurs locally on the Android smartphone. The evaluation of the remote expression (E2) occurs in the cloud and the result is sent to the phone. The CombinedExpression in \ref{eq:localcombinedexpression} is evaluated on the phone based on the results from E1 and E2. 

The evaluation of a SWAN-Song expression composed by two remote sub-expressions, instead, is completely evaluated in the cloud.
\begin{equation}
E1 = cloud@thingspeak:field?channelid='1' \#field='1'\big\{MEAN,200s\big\} > 50.0
\end{equation}
\begin{equation}
E2 = cloud@thingspeak:field?channelid='2' \#field='1'\big\{MEAN,200s\big\} > 50.0
\end{equation}
\begin{equation} \label{eq:remotecombinedexpression}
CombinedExpression = E1 \text{ \&\& } E2
\end{equation}

The result of the combined expression in \ref{eq:remotecombinedexpression} is evaluated on the cloud; the combined result is then sent to the phone.
\subsubsection{Cloud Manager}
The description below has been adapted from \cite{cowbirdarticle} and contains textual overlap with the paper. The evaluation engine running on the smartphone registers an expression to the cloud manager using three parameters: the expression identifier, the expression itself and the location (URL) of the expression. The cloud manager makes a HTTP POST request to the cloud indicated by the expression with the id, expression and a Firebase token. The cloud manager runs a Firebase Message Service used to receive the result of the evaluation computed in the cloud. The result is received at the smartphone side as push notification through Firebase Cloud Messaging. 
% We chose Firebase Cloud Messaging because sensor data is typically less than 4KB (maximum payload). 
Since Cowbird is Android-based, the Google Play Service already has socket connections to the Firebase server and multiple applications can use this service to minimize battery consumption. The message received from the server contains the result of the expression which can be either a new value or a new TriState (TRUE, FALSE, UNDEFINED) and the expression id. The Cloud manager sends this data to the evaluation engine service for local evaluation. After the local evaluation, the final result is sent to the app.
\subsubsection{Cloud Instance}
The description below has been adapted from \cite{cowbirdarticle} and contains textual overlap with the paper. The Cowbird cloud instance is implemented using the Play Framework \cite{playframeworkonline} with Java. The Cloud API contains a controller that routes a specific URL to a functionality. The cloud instance supports requests to register expressions both from mobile clients and web clients. The Cowbird cloud instance currently supports various IoT sensors such as ThingSpeak, The Things Network, Twitter, News, Weather, Currency and Flight. Additional sensors can be easily added as a plugin. Sensors are implemented as Java threads.

 \begin{figure}[ht!]
\includegraphics[width=1\textwidth]{images/cowbird_communication.pdf}
 \caption{SWAN smartphone and Cowbird communication architecture.}
\label{fig:cowbird_communication_architecture}
\end{figure}

On receiving a request from the phone, the Cloud API forwards it to the evaluation engine. The evaluation engine will start the relevant sensor thread that will keep polling external web data from an endpoint. The sensor data is sent back to the evaluation engine which will evaluate the data;  expression evaluation performed in a multi-threaded fashion. The evaluation result is sent to the Cloud API that will forward it to the phone.
%along with the registered token and the framework’s API key \cite{cowbirdarticle}
The communication between the Cowbird cloud instance and the phone happens through Firebase push notification (see Figure \ref{fig:cowbird_communication_architecture}).
\subsection{Optimization}
The process of sending back from the Cowbird cloud instance to the smartphone the result of a SWAN-Song Tristate expression has been optimized. The result is sent back only if there is a change in the evaluation (e.g., from FALSE to TRUE) and not every time a sensor value changes \cite{cowbirdarticle}. Minimizing the communication between the phone and the cloud reduces the energy consumption and preserves the smartphone battery life.
\section{Cowbird Limitations}
The Cowbird architecture presents some limitations. In particular, the current implementation of the cloud instance does not scale since it is designed to run on a single computing node. Now imagine a scenario where many expressions from different smartphones are offloaded to the cloud; thus, many threads are instantiated in order to fetch the sensor data. Multiple running threads can easily saturate the computing resources especially if each thread performs updates with a high frequency. Furthermore, each sensor generates an unbounded and potentially infinite stream of data that has to be processed by the evaluation engine. The huge amount of data that has to be processed can overwhelm the computing resources (i.e. CPU, memory) and reduce the overall performance of the framework.

In order to evaluate the streams of data generated by the IoT sensors in real-time a distributed computing architecture is required. In the next chapters we will investigate how such infrastructure can be built and how the Cowbird cloud instance can be extended. We will focus on how Cowbird can accommodate SWAN-Song expressions evaluation on a large scale.